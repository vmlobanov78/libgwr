/*
    *****************************************************************************
    *                                                                           *
    *   libgwr-treestore-nodes.hi                                               *
    *                                                                           *
    *   --------------------------------------------------------------------    *
    *                                                                           *
    *   Part of libwgwr                                                         *
    *                                                                           *
    *   Copyright (C) 2011-2013 Guillaume Wardavoir                             *
    *   Inspiration             Tim-Philipp Müller                              *
    *                                                                           *
    *   --------------------------------------------------------------------    *
    *                                                                           *
    *   Tim-Philipp Müller wrote the excellent "GTK+ 2.0 Tree View Tutorial"    *
    *   whose section 11 'writing custom models' is the base of the             *
    *   Treestore code.                                                         *
    *
    *   --------------------------------------------------------------------    *
    *                                                                           *
    *   This program is free software; you can redistribute it and/or modify    *
    *   it under the terms of the GNU General Public License as published by    *
    *   the Free Software Foundation; either version 2 of the License, or       *
    *   (at your option) any later version.                                     *
    *                                                                           *
    *   This program is distributed in the hope that it will be useful,         *
    *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *
    *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *
    *   GNU General Public License for more details.                            *
    *                                                                           *
    *   You should have received a copy of the GNU General Public License       *
    *   along with this program; if not, write to the Free Software             *
    *   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301,   *
    *   USA.                                                                    *
    *                                                                           *
    *   --------------------------------------------------------------------    *
    *                                                                           *
    *   Namespace   : libgwr::treestore                                         *
    *                                                                           *
    *   Class       : Store                                                     *
    *                                                                           *
    *   Purpose     : Header                                                    *
    *                                                                           *
    *****************************************************************************
*/


/**
  *
  ******************************************************************************

  \struct    PNode

  ******************************************************************************
  *
  * \class  PNode
  *
  * \brief  The Node struct contains :
  *     - a row's data.
  *     - a NodeBlock struct, containing its children nodes
  *
  */
class   PNode
{
    friend class    PNodeBlock;
    friend class    NodeRoot;

    private:
    //  ------------------------------------------------------------------------
    enum
    {
        e_UID_SHIFT			= 0												,
        e_UID_BITS			= GWR_B32(00000000,00001111,11111111,11111111)  ,
        e_UID_MASK			= ~e_UID_BITS									,

        e_SHOWN_SHIFT       = 20                                            ,
        e_SHOWN_BITS        = GWR_B32(00000000,00110000,00000000,00000000)  ,
        e_SHOWN_MASK        = ~e_SHOWN_BITS                                 ,

        e_VISIBILITY_SHIFT  = 22											,
        e_VISIBILITY_BITS   = GWR_B32(00000000,01000000,00000000,00000000)  ,
        e_VISIBILITY_MASK   = ~e_VISIBILITY_BITS                            ,

        e_RTNODE_SHIFT      = 31                                            ,
        e_RTNODE_BITS       = GWR_B32(10000000,00000000,00000000,00000000)  ,
        e_RTNODE_MASK       = ~e_RTNODE_BITS
    };
    //  ------------------------------------------------------------------------
    private:
    guint32								a_bits;     //!< contain the flag bits

    protected:
    Node							*   a_parent;                               //!< parent Node
    NodeBlock						*   d_children;                             //!< children
    IData                           *	d_data;                                 //!< user data
    guint16                             a_spos;                                 //!< Shown  index in the parent's NodeBlock
    guint16                             a_hpos;                                 //!< Hidden index in the parent's NodeBlock
    Node							*   a_aprev;                                //!< prev Absolute node
    Node							*   a_anext;                                //!< next Absolute node
    Node							*   a_snext;                                //!< next Shown node
    //  ------------------------------------------------------------------------
    //  get / set
    private:
    inline  void            set_uid             (guint32 _uid)  { flags_set_uid(_uid);  }

    inline  void		    inc_spos            ()	            { a_spos++;		        }
    inline  void		    dec_spos            ()	            { a_spos--;             }
    inline  void		    set_spos            (guint16 _p)    { a_spos = _p;          }

    inline  void		    inc_hpos            ()	            { a_hpos++;		        }
    inline  void		    dec_hpos            ()	            { a_hpos--;             }
    inline  void		    set_hpos            (guint16 _p)    { a_hpos = _p;          }

    inline  void	        set_aprev           (Node *_n)	    { a_aprev = _n;         }
    inline  void	        set_anext           (Node *_n)	    { a_anext = _n;         }
    inline  void	        set_snext           (Node *_n)	    { a_snext = _n;         }

    inline  void            flags_set_uid       (guint32 _uid)  { a_bits &= e_UID_MASK;                 a_bits |= ( ((guint32)(_uid  << e_UID_SHIFT   )) & e_UID_BITS   );  }
    inline  void            flags_set_shown     (guint32 _i)    { a_bits &= e_SHOWN_MASK;               a_bits |= ( ((guint32)(_i    << e_SHOWN_SHIFT )) & e_SHOWN_BITS );  }
    inline  void            flags_set_visibility(gboolean _v)   {                               _v ?    a_bits |= e_VISIBILITY_BITS  : a_bits &= e_VISIBILITY_MASK;         }
    inline  void            flags_set_rtnode    ()              {                                       a_bits |= e_RTNODE_BITS;                                            }

    protected:
    inline  guint32         flags_get_uid       ()              { return ( a_bits & e_UID_BITS		    ) >> e_UID_SHIFT;					}
    inline  guint32         flags_get_shown     ()              { return ( a_bits & e_SHOWN_BITS        ) >> e_SHOWN_SHIFT;                 }
    inline  gboolean        flags_get_visibility()              { return ( a_bits & e_VISIBILITY_BITS   ) != (guint32)0 ? TRUE  : FALSE;	}
    inline  gboolean        flags_get_rtnode    ()              { return ( a_bits & e_RTNODE_BITS       ) != (guint32)0 ? TRUE  : FALSE;	}

    inline  Node        *   aprev               ()              { return a_aprev;       }
    inline  Node        *   anext               ()              { return a_anext;       }
    inline  Node        *   snext               ()              { return a_snext;       }
    //inline  guint16         spos                ()              { return a_spos;        }
    inline  guint16         schildpos           (PNode* _n)     { return children()->d_snodes->pos((Node*)_n);        }
    inline  guint16         spos                ()              { return PNODE(parent())->schildpos(this);        }
    inline  guint16         hpos                ()              { return a_hpos;        }

    inline  Node		*   parent              ()	            { return a_parent;                                          }
    inline	NodeBlock	*   brothers            ()	            { return a_parent ? PNODE(a_parent)->d_children : NULL;     }
    inline	NodeBlock	*   children            ()	            { return d_children;	                                    }
    inline	IData       *&	data                ()              { return d_data;                                            }

    //  ------------------------------------------------------------------------
    //  find
    private:
            Node        *   find_anext_shown    ();
            Node        *   find_anext_hidden   ();
    //  ------------------------------------------------------------------------
    //  remove
    protected:
            guint32		    remove_child        (guint16 _pos);
            guint32		    remove_children     ();
    //  ------------------------------------------------------------------------
    //  show / hide
    protected:
            gboolean        visibility_changed  ();
    //  ------------------------------------------------------------------------
    //  debug
    public:
            const gchar     *	log();
            void                dump_tree(guint32 _level = 0);
            gboolean            check();
    //  ------------------------------------------------------------------------
    protected:
            PNode(
                guint32         _uid    ,
                gint            _depth  ,
                guint16         _spos   ,
                guint16         _hpos   ,
                Node        *   _parent,
                IData       *   _data);
    virtual ~PNode();
};
/**
  *
  ******************************************************************************

  \class    Node

  ******************************************************************************
  *
  * \class  Node
  *
  * \brief  This class is mainly a wrapper for PNode, which it ineherits from.
  *     It wraps on :
  *         - PNode    methods, which modify internals
  *         - parent() methods, when necessary
  *
  */
class   Node : public PNode
{
    friend class    PNode;
    friend struct   Store;
    friend struct   NodeBlock;
    friend struct   PNodeBlock;
    private:
    //  ------------------------------------------------------------------------
    static  gint Count;
    static  gint Remaining()	{ return Count; }
    //  ------------------------------------------------------------------------
    //  get / set
    inline  guint32				uid             ()		        { return    PNode::flags_get_uid();                 }

    inline  gboolean			shown           ()	            { return  ( PNode::flags_get_shown() != 0 );        }
    inline  gboolean			hidden          ()	            { return  ( PNode::flags_get_shown() == 0 );        }
    inline  gboolean			visibility      ()	            { return  PNode::flags_get_visibility();            }

    inline  guint16			    pos             ()	            { return a_spos;                                    }
    inline  gint				depth           ()              { return a_parent ? a_parent->children()->depth() : 0;  }

    inline  Node			*   parent          ()	            { return a_parent;                                  }
    inline	Node			*   next            ()	            { return a_snext;                                   }
    inline	NodeBlock		*   brothers        ()	            { return PNode::brothers();                         }
    inline	NodeBlock		*   children        ()	            { return d_children;	                            }

    inline	gboolean		    sterile()	                    { return children()->empty();                       }

    inline	IData           *&	data()		                    { return d_data;		                            }

            guint32				row();
    //  ------------------------------------------------------------------------
    //  remove
    private:
    inline  guint16				remove_one_child(guint16 _pos)  { return PNode::remove_child(_pos);                 }
    inline  guint16				remove_all_children()           { return PNode::remove_children();                  }
    //  ------------------------------------------------------------------------
    //  debug
    public:
    inline  const gchar     *	log()                           { return PNode::log();          }
    inline  void                dump_tree(guint32 _level = 0)   { PNode::dump_tree(_level);     }
    //  ------------------------------------------------------------------------
    protected:
    void*		operator new	(size_t size);
    void		operator delete (void *p);

    Node(guint32 _uid, gint _depth, guint16 _spos, guint16 _hpos, Node *_parent, IData* _data) :
        PNode(_uid, _depth, _spos, _hpos, _parent, _data)       {}
    virtual ~Node() {}
};
/**
  *
  ******************************************************************************

  \class    NodeRoot

  ******************************************************************************
  *
  * \class   NodeRoot
  *
  */
class   NodeRoot : public Node
{
    public:

    NodeRoot(guint32 _uid, gint _depth, guint16 _spos, guint16 _hpos, Node *_parent, IData* _data) :
        Node(_uid, _depth, _spos, _hpos, _parent, _data)
    {
        flags_set_rtnode();
        flags_set_shown(2);
        flags_set_visibility(TRUE);
    }

    virtual ~NodeRoot() {}
};
